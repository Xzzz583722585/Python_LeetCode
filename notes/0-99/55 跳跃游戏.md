# 题目描述

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

示例 1:

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
示例 2:

输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。

# 解题思路

以示例 1，[2,3,1,1,4]来看：
当我们站在起点的位置时，我们当前能到达的点包括[2(0)]，小括号内为该点下标。
从点2(0)出发，由于其长度为2，故我们当前能到达的点包括[3(1), 1(2)]。
从点3(1)出发，由于其长度为3，故我们当前能到达的点包括[1(2), 1(3), 4(4)]。
从点1(2)出发，由于其长度为1，故我们当前能到达的点包括[1(3), 4(4)]。
从点1(3)出发，由于其长度为1，故我们当前能到达的点包括[4(4)]。
取出点4(4)，到达终点。

以示例 2，[3,2,1,0,4]来看：
当我们站在起点的位置时，我们当前能到达的点包括[3(0)]，小括号内为该点下标。
从点3(0)出发，由于其长度为3，故我们当前能到达的点包括[2(1), 1(2), 0(3)]。
从点2(1)出发，由于其长度为2，故我们当前能到达的点包括[1(2), 0(3)]。
从点1(2)出发，由于其长度为1，故我们当前能到达的点包括[0(3)]。
从点0(3)出发，由于其长度为0，故我们当前能到达的点包括[]。
已经不能继续向后走了，我们判断出没有走完整个路程，即不能到达终点。

总结：
我们只需要挨个遍历数组，判断能否到达数组尾即可。
但是我们的精力有限，每遍历一个元素都会消耗一点精力。
每个元素都可以补充我们的精力，但它不是游戏里的血瓶，简单地做加法，而是将我们的精力变为当前元素的值。
很明显，我们需要更多的精力，才能够到达终点，所以，只有当当前元素的值大于我们的精力时，我们才选择补充精力。
当我们精疲力竭，还未到达终点时，我们就输了。
当我们抵达终点，我们就赢了。

# 代码实现

``` python
class Solution:
    def canJump(self, nums):
        dump_nums = 1    # 还能跳跃的能量，每跳一格消耗一格能量，进入第一个位置就消耗一个能量
        index = 0   # 位置标记

        while dump_nums > 0 and index < len(nums):
            dump_nums -= 1   # 消耗能量
            if nums[index] > dump_nums:  # 充能
                dump_nums = nums[index]
            index += 1

        return index == len(nums)
```